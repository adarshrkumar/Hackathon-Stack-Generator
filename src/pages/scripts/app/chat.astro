---
/**
 * Shared Chat Script Component
 *
 * Contains common chat functionality used by both index.astro and [id].astro
 * Accepts props to customize behavior for different page types
 */

interface Props {
    serverThreadData?: {
        threadId: string | null;
        threadTitle: string | null;
        threadNotFound?: boolean;
    } | null;
    isThreadPage?: boolean;
}

const { serverThreadData = null, isThreadPage = false } = Astro.props;
---

<!-- Client-Side TypeScript -->
<script is:inline define:vars={{ serverThreadData, isThreadPage }}>
    import { marked } from 'marked';

    // Configure marked for better rendering
    marked.setOptions({
        breaks: true,  // Convert line breaks to <br>
        gfm: true,     // GitHub Flavored Markdown
    });

    /**
     * Chat State Variables
     */

    // Cookie name for thread ID persistence
    const COOKIE_NAME = 'stack-generator-thread-id';

    // Helper to set cookie
    function setCookie(name, value, days = 30) {
        const expires = new Date();
        expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
        document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
    }

    // Helper to delete cookie
    function deleteCookie(name) {
        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/`;
    }

    // Helper to get cookie value
    function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop()?.split(';').shift() || null;
        return null;
    }

    // Current conversation thread ID (null for new conversations)
    let currentThreadId = getCookie(COOKIE_NAME);

    // In-memory message history (for reference, not sent to API)
    let messageHistory = [];

    /**
     * DOM Element References
     */
    const chatMessages = document.getElementById('chatMessages');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    const errorBanner = document.getElementById('errorBanner');
    const threadInfo = document.getElementById('threadInfo');
    const newChatBtn = document.getElementById('newChatBtn');

    /**
     * Initialize state from server-rendered DOM (only for thread page)
     */
    if (isThreadPage && serverThreadData) {
        const threadId = serverThreadData?.threadId;
        const threadTitle = serverThreadData?.threadTitle;
        const threadNotFound = serverThreadData?.threadNotFound === true;

        // Handle deleted/invalid thread
        if (threadNotFound) {
            console.log('Thread not found or deleted, starting new conversation');
            currentThreadId = null;
            deleteCookie(COOKIE_NAME);
            threadInfo.textContent = 'New conversation';
            chatMessages.scrollTop = chatMessages.scrollHeight;
        } else {
            // Extract messages from server-rendered DOM
            const existingMessages = chatMessages.querySelectorAll('.message');

            existingMessages.forEach((msgEl) => {
                // Skip welcome message (don't add to history)
                const contentEl = msgEl.querySelector('.message-content');
                const isWelcome = contentEl?.innerHTML.includes('Welcome to Stack Generator');

                if (!isWelcome) {
                    const role = msgEl.classList.contains('user') ? 'user' : 'assistant';
                    const content = contentEl?.innerHTML || '';
                    messageHistory.push({ role: role, content });
                }
            });

            // Load thread data if available
            if (threadId) {
                currentThreadId = threadId;
                setCookie(COOKIE_NAME, threadId);

                // Update thread info
                if (threadTitle) {
                    threadInfo.textContent = `Thread: ${threadTitle}`;
                } else {
                    threadInfo.textContent = `Thread: ${threadId.substring(0, 8)}`;
                }
            }

            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }

    /**
     * Auto-Resize Textarea
     *
     * Automatically adjusts the height of the textarea as the user types
     * to accommodate multi-line messages without manual scrolling
     */
    messageInput.addEventListener('input', () => {
        messageInput.style.height = 'auto';  // Reset height
        messageInput.style.height = messageInput.scrollHeight + 'px';  // Set to content height
    });

    /**
     * Keyboard Shortcut: Enter to Send
     *
     * - Enter: Send message
     * - Shift+Enter: Insert newline (default textarea behavior)
     */
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();  // Prevent newline
            sendMessage();       // Send the message
        }
    });

    /**
     * Send Button Click Handler
     */
    sendButton.addEventListener('click', sendMessage);

    /**
     * New Chat Button Handler
     */
    if (newChatBtn) {
        newChatBtn.addEventListener('click', () => {
            if (isThreadPage) {
                window.location.href = '/app/chat/';
            } else {
                window.location.reload();
            }
        });
    }

    /**
     * Send Message Function
     *
     * Handles the complete message sending flow
     */
    async function sendMessage() {
        // Get and validate message text
        const message = messageInput.value.trim();
        if (!message) return;  // Don't send empty messages

        // Clear input and reset height
        messageInput.value = '';
        messageInput.style.height = 'auto';

        // Add user message to UI immediately for better UX
        addMessage('user', message);

        if (isThreadPage) {
            messageHistory.push({ role: 'user', content: message });
        }

        // Disable input while waiting for response
        setInputState(false);

        // Show loading indicator
        const loadingEl = addLoadingMessage();

        try {
            /**
             * Prepare API Request
             */
            const requestBody = { text: message };
            if (currentThreadId) {
                requestBody.id = currentThreadId;
            }

            /**
             * Send Request to API
             */
            const response = await fetch('/api/message/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
            });

            // Parse JSON response
            const data = await response.json();

            // Check for HTTP errors
            if (!response.ok) {
                // If thread is unauthorized or not found, clear it and start fresh
                if (response.status === 403 || response.status === 404) {
                    console.log('Thread invalid or unauthorized, clearing and starting new conversation');
                    currentThreadId = null;
                    deleteCookie(COOKIE_NAME);
                    threadInfo.textContent = 'New conversation';
                }
                throw new Error(data.error || 'Request failed');
            }

            // Remove loading indicator
            loadingEl.remove();

            // If this is the index page, redirect to the thread page
            if (!isThreadPage && data.id) {
                window.location.href = `/app/chat/${data.id}`;
                return;
            }

            /**
             * Add AI Response to UI (thread page only)
             */
            if (isThreadPage) {
                addMessage('assistant', data.generatedText);
                messageHistory.push({ role: 'assistant', content: data.generatedText });

                /**
                 * Update Thread Info
                 */
                if (data.id) {
                    currentThreadId = data.id;
                    setCookie(COOKIE_NAME, data.id);
                    threadInfo.textContent = `Thread: ${data.generatedTitle || data.id.substring(0, 8)}`;
                }
            }

            // Clear any previous errors
            hideError();

        } catch (error) {
            /**
             * Error Handling
             */
            loadingEl.remove();
            showError(error instanceof Error ? error.message : String(error));

            // Remove the user message from history since request failed
            if (isThreadPage) {
                messageHistory.pop();
            }

        } finally {
            /**
             * Re-enable Input
             */
            setInputState(true);
            messageInput.focus();
        }
    }

    /**
     * Add Message to UI
     *
     * Creates a message element and appends it to the chat messages container
     * AI messages are rendered as markdown for better formatting
     *
     * @param role - 'user' or 'assistant'
     * @param content - The message text
     */
    function addMessage(role, content) {
        // Create message container
        const messageEl = document.createElement('div');
        messageEl.className = `message ${role}`;

        // Select appropriate icon
        const icon = role === 'user' ? 'fa-user' : 'fa-robot';

        // Format content based on role
        let formattedContent;
        if (role === 'assistant') {
            // Render markdown for AI responses
            formattedContent = marked.parse(content);
        } else {
            // Escape HTML for user messages to prevent XSS
            formattedContent = escapeHtml(content).replace(/\n/g, '<br>');
        }

        // Build message HTML with icon and content
        messageEl.innerHTML = `
            <div class="message-icon">
                <i class="fa-solid ${icon}"></i>
            </div>
            <div class="message-content">${formattedContent}</div>
        `;

        // Append to chat and scroll to bottom
        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    /**
     * Add Loading Message
     *
     * Creates a loading indicator message to show while waiting for AI response
     *
     * @returns The loading element (so it can be removed later)
     */
    function addLoadingMessage() {
        const loadingEl = document.createElement('div');
        loadingEl.className = 'message assistant loading';

        // Create animated typing indicator
        loadingEl.innerHTML = `
            <div class="message-icon">
                <i class="fa-solid fa-robot"></i>
            </div>
            <div class="message-content">
                <div class="typing-indicator">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        `;

        // Append and scroll to bottom
        chatMessages.appendChild(loadingEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        return loadingEl;
    }

    /**
     * Set Input State
     *
     * Enable or disable the message input and send button
     * Used to prevent multiple simultaneous messages
     *
     * @param enabled - true to enable input, false to disable
     */
    function setInputState(enabled) {
        messageInput.disabled = !enabled;
        sendButton.disabled = !enabled;
    }

    /**
     * Show Error Banner
     *
     * Displays an error message at the top of the chat input area
     *
     * @param message - The error message to display
     */
    function showError(message) {
        errorBanner.textContent = `Error: ${message}`;
        errorBanner.classList.add('show');
    }

    /**
     * Hide Error Banner
     *
     * Hides the error message banner
     */
    function hideError() {
        errorBanner.textContent = '';
        errorBanner.classList.remove('show');
    }

    /**
     * Escape HTML
     *
     * Prevents XSS attacks by escaping HTML special characters
     * in user and AI generated content
     *
     * @param text - The text to escape
     * @returns HTML-safe text
     */
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
</script>
